#!/usr/bin/python
import sys, os, glob, shutil, numpy

from netCDF4 import *
from netCDF4 import Dataset as NetCDFFile
from pylab import *

from optparse import OptionParser

import collections
point = collections.namedtuple('Point', ['x', 'y', 'z'])

def circumcenter(on_sphere, x1, y1, z1, x2, y2, z2, x3, y3, z3):#{{{
	p1 = point(x1, y1, z1)
	p2 = point(x2, y2, z2)
	p3 = point(x3, y3, z3)
	if on_sphere:
		a = (p2.x - p3.x)**2 + (p2.y - p3.y)**2 + (p2.z - p3.z)**2
		b = (p3.x - p1.x)**2 + (p3.y - p1.y)**2 + (p3.z - p1.z)**2
		c = (p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2

		pbc = a*(-a + b + c);
		apc = b*( a - b + c);
		abp = c*( a + b - c);

		xv = (pbc * p1.x + apc * p2.x + abp * p3.x) / (pbc + apc + abp)
		yv = (pbc * p1.y + apc * p2.y + abp * p3.y) / (pbc + apc + abp)
		zv = (pbc * p1.z + apc * p2.z + abp * p3.z) / (pbc + apc + abp)
	else:
		d = 2 * (p1.x  * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))

		xv = ((p1.x**2 + p1.y**2) * (p2.y - p3.y) + (p2.x**2 + p2.y**2) * (p3.y - p1.y) + (p3.x**2 + p3.y**2) * (p1.y - p2.y)) / d
		yv = ((p1.x**2 + p1.y**2) * (p3.x - p2.x) + (p2.x**2 + p2.y**2) * (p1.x - p3.x) + (p3.x**2 + p3.y**2) * (p2.x - p1.x)) / d
		zv = 0.0

                xv = p1.x + p2.x + p3.x
                xv = xv / 3.0
                yv = p1.y + p2.y + p3.y
                yv = yv / 3.0
	return point(xv, yv, zv)

#}}}

parser = OptionParser()
parser.add_option("-n", "--node", dest="node", help="input .node file generated by Triangle.", metavar="FILE")
parser.add_option("-e", "--ele", dest="ele", help="input .ele file generated by Triangle.", metavar="FILE")
#parser.add_option("-c", "--cells", dest="cells", help="input file containing x, y, z cell locations.", metavar="FILE")
#parser.add_option("-v", "--vertices", dest="vertices", help="input file containing x, y, z, vertex locations.", metavar="FILE")
#parser.add_option("-C", "--cellsOnVertex", dest="cellsOnVertex", help="input file containing connectivity between cells and vertices.", metavar="FILE")
#parser.add_option("-d", "--density", dest="density", help="input file containing density function values at cell centers.", metavar="FILE")
parser.add_option("-o", "--output", dest="output", help="output file name.", metavar="FILE")
#parser.add_option("-s", "--spherical", dest="spherical", action="store_true", default=False, help="Determines if the input/output should be spherical or not.")

options, args = parser.parse_args()

if not options.node:
	parser.error("A .node file is required.")

if not options.ele:
	parser.error("A .ele file is required.")

options.density=False  # I'm not sure if we can get this or not...
if not options.density:
	const_dens = True
else:
	const_dens = False

if not options.output:
	output_name = "grid.nc"
else:
	output_name = options.output

# These will always be planar meshes
on_sphere = False


grid = NetCDFFile(output_name, 'w', format='NETCDF3_CLASSIC')

# Get dimensions

# Get nCells
cell_info = open(options.node, 'r')
nCells = -1  # There is one header line
for block in iter(lambda: cell_info.readline(), ""):
	if block.startswith("#"):
		continue  # skip comment lines
	nCells = nCells + 1
cell_info.close();

# Get vertexDegree and nVertices
cov_info = open(options.ele, 'r')
vertexDegree = 3 # always triangles with Triangle!
nVertices = -1 # There is one header line
for block in iter(lambda: cov_info.readline(), ""):
	if block.startswith("#"):
		continue  # skip comment lines
	nVertices = nVertices + 1
cov_info.close()

if vertexDegree != 3:
	parser.error("This script can only compute vertices with triangular dual meshes currently.")

nCells_dim = grid.createDimension('nCells', nCells)
nVertices_dim = grid.createDimension('nVertices', nVertices)
vertexDegree_dim = grid.createDimension('vertexDegree', vertexDegree)

# Create cell variables and sphere_radius
sphere_radius = 0.0

xCell_full = grid.createVariable('xCell', 'f8', ( 'nCells' ,) )
yCell_full = grid.createVariable('yCell', 'f8', ( 'nCells' ,) )
zCell_full = grid.createVariable('zCell', 'f8', ( 'nCells' ,) )

cell_info = open(options.node, 'r')
cell_info.readline()  # read header
i = 0
for block in iter(lambda: cell_info.readline(), ""):
	block_arr = block.split()
	if block_arr[0] == "#":
		continue  # skip comment lines
	xCell_full[i] = float(block_arr[1])
	yCell_full[i] = float(block_arr[2])
	zCell_full[i] = 0.0  # z-position is always 0.0 in a planar mesh
	i = i + 1
cell_info.close()

if on_sphere:
	grid.on_a_sphere = "YES"
	grid.sphere_radius = sphere_radius
else:
	grid.on_a_sphere = "NO"
	grid.sphere_radius = 0.0

# Create cellsOnVertex
cellsOnVertex_full = grid.createVariable('cellsOnVertex', 'i4', ( 'nVertices' , 'vertexDegree' ,) )

cov_info = open(options.ele, 'r')
cov_info.readline()  # read header
iVertex = 0
for block in iter(lambda: cov_info.readline(), ""):
	block_arr = block.split()
	if block_arr[0] == "#":
		continue  # skip comment lines
	cellsOnVertex_full[iVertex,:] = int(-1)
	for j in np.arange(0, 3):  # skip the first column, which is the triangle number, and then only get the next 3 columns
		cellsOnVertex_full[iVertex,j] = int(block_arr[j+1])

	iVertex = iVertex + 1

cov_info.close()

read_vertices=False  # we don't have vertex information from Triangle to read.. I don't think
if read_vertices:
	del xCell_full
	del yCell_full
	del zCell_full
	del cellsOnVertex_full

	# Create vertex variables
	xVertex_full = grid.createVariable('xVertex', 'f8', ( 'nVertices' ,) )
	yVertex_full = grid.createVariable('yVertex', 'f8', ( 'nVertices' ,) )
	zVertex_full = grid.createVariable('zVertex', 'f8', ( 'nVertices' ,) )

	vertex_info = open(options.vertices, 'r')
	i = 0
	for block in iter(lambda: vertex_info.readline(), ""):
		block_arr = block.split()
		xVertex_full[i] = float(block_arr[0])
		yVertex_full[i] = float(block_arr[1])
		zVertex_full[i] = float(block_arr[2])
		i = i+1
	vertex_info.close()

	del xVertex_full
	del yVertex_full
	del zVertex_full

else:
	# Create vertex variables
	xVertex_full = grid.createVariable('xVertex', 'f8', ( 'nVertices' ,) )
	yVertex_full = grid.createVariable('yVertex', 'f8', ( 'nVertices' ,) )
	zVertex_full = grid.createVariable('zVertex', 'f8', ( 'nVertices' ,) )

	for iVertex in arange(0, nVertices):
		cell1 = cellsOnVertex_full[iVertex,0]
		cell2 = cellsOnVertex_full[iVertex,1]
		cell3 = cellsOnVertex_full[iVertex,2]

		x1 = xCell_full[cell1-1]
		y1 = yCell_full[cell1-1]
		z1 = zCell_full[cell1-1]
		x2 = xCell_full[cell2-1]
		y2 = yCell_full[cell2-1]
		z2 = zCell_full[cell2-1]
		x3 = xCell_full[cell3-1]
		y3 = yCell_full[cell3-1]
		z3 = zCell_full[cell3-1]

		pv = circumcenter(on_sphere, x1, y1, z1, x2, y2, z2, x3, y3, z3)
		xVertex_full[iVertex] = pv.x
		yVertex_full[iVertex] = pv.y
		zVertex_full[iVertex] = pv.z

	del xCell_full
	del yCell_full
	del zCell_full
	del xVertex_full
	del yVertex_full
	del zVertex_full
	del cellsOnVertex_full

if not options.density:
	meshDensity_full = grid.createVariable('meshDensity', 'f8', ( 'nCells' ,) )

	for iCell in arange(0, nCells):
		meshDensity_full[iCell] = 1.0

	del meshDensity_full
else:
	meshDensity_full = grid.createVariable('meshDensity', 'f8', ( 'nCells' ,) )
	density_info = open(options.density, 'r')
	iCell = 0
	for block in iter(lambda: density_info.readline(), ""):
		meshDensity_full[iCell] = float(block)
		iCell = iCell+1

	del meshDensity_full

grid.sync()
grid.close()


